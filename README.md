# Sleipnir

*Sleipnir is Odin's steed, the child of Loki and Svaðilfari - described as the best of all horses*

This is a potential companion project to [Mímir](https://github.com/hraberg/mimir) - but at its core it's a playground for [OpenCL](http://www.khronos.org/opencl/) and Clojure.
It uses [JOCL](http://jogamp.org/jocl/www/) (the jogamp version) under the hood. It's experimental, buggy and wildly incomplete for anything remotely useful. Mount at own risk.

Here's a start at a low level mapping layer:

```clojure
(defkernel vector-add [^float* a ^float* b ^:out ^float* c ^int num-elements]
  (let [^int iGID (get-global-id 0)]
    (when (< iGID num-elements)
      (aset c iGID (+ (aget a iGID) (aget b iGID))))))
```

Which maps to this OpenCL kernel:

```c
// OpenCL Kernel Function for element by element vector addition
kernel void VectorAdd(global const float* a, global const float* b, global float* c, int numElements) {

    // get index into global data array
    int iGID = get_global_id(0);

    // bound check (equivalent to the limit on a 'for' loop for standard/serial C code
    if (iGID >= numElements)  {
        return;
    }

    // add the vector elements
    c[iGID] = a[iGID] + b[iGID];
}
```

You can run the [`VectorAdd`](http://jogamp.org/wiki/index.php/JOCL_Tutorial) test in [`vector_add.clj`](https://github.com/hraberg/sleipnir/blob/master/test/sleipnir/test/vector_add.clj) by (you need an OpenCL SDK, I've only tested Intel's):

    lein run -m sleipnir.test.vector-add

The idea of writing the Kernels by hand in Clojure instead of OpenCL isn't the main point, but that a OpenCL subset representable in Clojure can be generated by different higher level macros.


## References

[JOCL Demos Reporistory](https://github.com/mbien/jocl-demos) (Bien, 2009)

[Declarative Parallel Programming for GPUs](http://www.osl.iu.edu/publications/prints/2011/2011-parco-holk-harlan.pdf) (Holk, Byrd et al,  2011)

[Efficient Relational Algebra Algorithms and Data Structures for GPU](http://www.cercs.gatech.edu/tech-reports/tr2012/git-cercs-12-01.pdf) (Diamos et al, 2012)

[The Declarative Imperative: Experiences and Conjectures in Distributed Logic](http://db.cs.berkeley.edu/jmh/talks/podskeynote10.pdf) (Hellerstein, 2010)

[Mars: A MapReduce Framework on Graphics Processors](http://www.cse.ust.hk/catalac/papers/mars_pact08.pdf) (He et al, 2008)

[Accelerate: An Embedded Language for Accelerated Array Computations](http://www.cse.unsw.edu.au/~chak/project/accelerate/) (Chakravarty et al, 2009)

[cl-gpu: A library for writing GPU (CUDA) kernels in a subset of Common Lisp](https://github.com/angavrilov/cl-gpu) (Gavrilov, 2009)

[Rootbeer GPU Compiler](https://github.com/pcpratts/rootbeer1) (Pratt-Szeliga, 2012)

[Aparapi: API for data parallel Java. Allows suitable code to be executed on GPU via OpenCL.](https://code.google.com/p/aparapi/) (Frost et al, 2010)
